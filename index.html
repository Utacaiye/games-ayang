<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="theme-color" content="#e11d48" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<title>Love Dash ‚Äî Tap Mode v2 üíò</title>
<meta name="description" content="Versi tap yang lebih responsif: ketuk hati untuk skor, hindari bom. Android & iPhone ready.">

<style>
  :root{ --rose:#e11d48; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Arial, 'Apple Color Emoji','Segoe UI Emoji';
    color:#5b0b1f;
    background: linear-gradient(180deg,#ffe4ea,#ffd9e1 45%,#ffd1da);
    min-height:100svh;
    display:flex;align-items:center;justify-content:center;
    padding-bottom:env(safe-area-inset-bottom);
  }
  .app{width:min(960px,100%);padding:16px}
  .card{background: rgba(255,255,255,.75); backdrop-filter: blur(6px); border-radius: 18px; padding:16px; box-shadow: 0 10px 30px rgba(225,29,72,.15)}
  h1{margin:0 0 4px;font-weight:800;color:#7f102a}
  .muted{color:#7c3042}
  .row{display:grid;gap:12px}
  @media(min-width:700px){.row{grid-template-columns:1fr 1fr}}

  .input{border:1px solid #f8bac6;border-radius:12px;padding:10px 12px;outline:none;width:100%}
  .input:focus{border-color:#fb7185; box-shadow:0 0 0 3px rgba(251,113,133,.25)}

  .btn{border:none; background:var(--rose); color:white; border-radius:14px; padding:12px 16px; font-weight:700; cursor:pointer; box-shadow:0 10px 16px rgba(225,29,72,.25)}
  .btn:hover{filter:brightness(.98)}
  .btn:active{transform:translateY(1px)}

  .hud{display:flex;gap:8px; align-items:center; justify-content:space-between; font-weight:700}
  .badge{background:#ffe3ea; color:#7f102a; padding:6px 10px; border-radius:999px; box-shadow: 0 2px 6px rgba(225,29,72,.12)}
  .badge.strong{background:#e11d48; color:white}
  .center{display:grid;place-items:center}

  .stage{position:relative;overflow:hidden;border-radius:16px; box-shadow: inset 0 0 0 1px rgba(225,29,72,.08)}
  canvas{display:block; width:100%; height:56.25vw; max-height:62vh; min-height:360px; background:linear-gradient(180deg,#fff,#ffe9ee); touch-action:none}

  .overlay{position:absolute; inset:0; display:grid; place-items:center; background:rgba(255,255,255,.7)}
  .hidden{display:none !important}
  .footer{margin-top:8px; text-align:center; color:#7c3042}
</style>
</head>
<body>
<div class="app">
  <div class="card" style="margin-bottom:12px">
    <h1>Love Dash üíù</h1>
    <div class="muted">Tap-hati yang lebih responsif ‚Äî Android & iPhone. Ketuk ‚ù§, jangan sentuh üí£.</div>
  </div>

  <div id="config" class="card" style="margin-bottom:12px">
    <div class="row">
      <label>Nama pasangan
        <input id="partnerName" class="input" placeholder="Dinda / Ayang / Sayang" value="Sayangku">
      </label>
      <label>Pesan spesial (muncul saat sukses)
        <input id="specialMsg" class="input" placeholder="Pesan romantis..." value="Kamu selalu jadi alasanku tersenyum. I love you!">
      </label>
      <label>Durasi (detik)
        <input id="duration" class="input" type="number" min="10" value="30">
      </label>
    </div>
    <div style="margin-top:10px; display:flex; gap:8px; align-items:center; justify-content:space-between; flex-wrap:wrap">
      <div style="display:flex; gap:8px; align-items:center">
        <button id="startBtn" class="btn">Mulai! üíò</button>
        <button id="muteBtn" class="btn" style="background:#7c3042">Sound: ON üîä</button>
      </div>
      <small class="muted">Kontrol: cukup <b>tap</b> hati. Jika tap bom, skor berkurang.</small>
    </div>
  </div>

  <div class="card stage">
    <div class="hud">
      <span class="badge strong" id="scoreBadge">Skor: 0</span>
      <span class="badge" id="timeBadge">Waktu: 30s</span>
      <span class="badge" id="bestBadge">Best: 0</span>
    </div>
    <div style="height:8px"></div>
    <canvas id="game" width="960" height="540"></canvas>

    <div id="endOverlay" class="overlay hidden">
      <div class="card center" style="text-align:center; padding:24px">
        <div id="endTitle" style="font-size:22px; font-weight:800; margin-bottom:8px">Waktu Habis!</div>
        <div id="endText" class="muted" style="margin-bottom:12px"></div>
        <button id="playAgain" class="btn">Main Lagi üíû</button>
      </div>
    </div>
  </div>

  <div class="footer">Tip: Tambahkan ke Home Screen di iPhone (Share‚ÜíAdd to Home Screen) atau Android (Add to Home Screen).</div>
</div>

<script>
/* =========================
   TUNING
   ========================= */
const THRESHOLD = 20;
const HEART_RATIO = 0.6;
const BASE_SPEED = 2.0;
const SPEED_SCALE = 0.035;
const SPAWN_BASE = 0.038;
const SPAWN_SCALE = 0.0012;
const HIT_RADIUS_SCALE = 0.75;
const AIM_ASSIST_PX = 28;

/* =========================
   RESPONSIVE CANVAS
   ========================= */
const $ = (sel) => document.querySelector(sel);
const canvas = $("#game");
const ctx = canvas.getContext("2d", { alpha:false, desynchronized:true });
function fitCanvas(){
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
new ResizeObserver(fitCanvas).observe(canvas);
window.addEventListener('orientationchange', ()=> setTimeout(fitCanvas, 250));
fitCanvas();

/* =========================
   SAFE TOUCH
   ========================= */
document.addEventListener('touchmove', (e)=>{
  if (e.target === canvas) e.preventDefault();
},{ passive:false });
document.body.style.overscrollBehavior = 'contain';

/* =========================
   UI
   ========================= */
const partnerInput = $("#partnerName");
const specialMsgInput = $("#specialMsg");
const durationInput = $("#duration");
const startBtn = $("#startBtn");
const muteBtn = $("#muteBtn");
const scoreBadge = $("#scoreBadge");
const timeBadge = $("#timeBadge");
const bestBadge = $("#bestBadge");
const endOverlay = $("#endOverlay");
const endTitle = $("#endTitle");
const endText = $("#endText");
const playAgain = $("#playAgain");

const store = {
  get best(){ try{ return Number(localStorage.getItem("loveDashBestTapV2")||0) }catch{ return 0 } },
  set best(v){ try{ localStorage.setItem("loveDashBestTapV2", v) }catch{} }
};
bestBadge.textContent = "Best: " + store.best;

/* =========================
   AUDIO
   ========================= */
let audioCtx = null;
let soundMuted = false;
function ensureAudio(){
  if(!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}
async function unlockAudio(){
  ensureAudio();
  try{
    if (audioCtx.state === 'suspended') { await audioCtx.resume(); }
    const b = audioCtx.createBuffer(1, 1, audioCtx.sampleRate);
    const s = audioCtx.createBufferSource(); s.buffer = b;
    s.connect(audioCtx.destination); s.start(0); s.stop(0);
  }catch{}
}
function beep(freq=880, dur=0.08, type="sine", gain=0.12){
  if(soundMuted) return;
  ensureAudio();
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.frequency.value = freq; osc.type = type;
  g.gain.value = gain;
  osc.connect(g).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + dur);
}
function chordSuccess(){
  if(soundMuted) return;
  ensureAudio();
  const freqs = [523,659,784];
  const now = audioCtx.currentTime;
  freqs.forEach((f,i)=>{
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = "sine"; o.frequency.value = f;
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.12, now+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now+0.35+i*0.02);
    o.connect(g).connect(audioCtx.destination);
    o.start(now + i*0.02);
    o.stop(now + 0.4 + i*0.02);
  });
}
function boom(){
  if(soundMuted) return;
  ensureAudio();
  const bufferSize = 2 * audioCtx.sampleRate;
  const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const output = noiseBuffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
  const white = audioCtx.createBufferSource(); white.buffer = noiseBuffer;
  const filter = audioCtx.createBiquadFilter(); filter.type = "lowpass"; filter.frequency.value = 220;
  const g = audioCtx.createGain(); g.gain.value = 0.22;
  white.connect(filter).connect(g).connect(audioCtx.destination);
  white.start(); white.stop(audioCtx.currentTime + 0.2);
}

/* =========================
   GAME
   ========================= */
const state = {
  running:false,
  time:30,
  score:0,
  objects:[],
  particles:[],
};
let lastTs = 0;

function reset(){
  state.time = +durationInput.value || 30;
  state.score = 0;
  state.objects = [];
  state.particles = [];
  scoreBadge.textContent = "Skor: 0";
  timeBadge.textContent = `Waktu: ${state.time}s`;
}

function start(){
  reset();
  state.running = true;
  endOverlay.classList.add("hidden");
  lastTs = performance.now();
  unlockAudio(); // non-blocking
  requestAnimationFrame(loop);
}

function end(){
  state.running = false;
  const partner = partnerInput.value || "Sayangku";
  const spMsg = specialMsgInput.value || "";
  const success = state.score >= THRESHOLD;
  endTitle.textContent = success ? `Kamu hebat, ${partner}! üéâ` : "Waktu Habis! ‚è∞";
  endText.textContent = success ? spMsg : `${partner}, kamu dapat ${state.score} poin. Yuk coba lagi!`;
  endOverlay.classList.remove("hidden");
  if (success) chordSuccess(); else beep(400,0.2,"sine",0.08);
  if (state.score > store.best){ store.best = state.score; }
  bestBadge.textContent = "Best: " + store.best;
}

function spawn(){
  const isHeart = Math.random() < HEART_RATIO;
  const size = (isHeart ? 26 : 24) + Math.random()*12;
  const speed = BASE_SPEED + Math.random()*1.6 + Math.min(state.score*SPEED_SCALE, 1.8);
  state.objects.push({
    type: isHeart ? "heart" : "bomb",
    x: 40 + Math.random()*(canvas.width-80),
    y: -size-10,
    size, speed,
    phase: Math.random()*Math.PI*2
  });
}

function loop(ts){
  if(!state.running) return;
  const dt = Math.min(32, ts - lastTs);
  lastTs = ts;

  if (Math.random() < SPAWN_BASE + Math.min(state.score*SPAWN_SCALE, 0.024)) spawn();

  state.objects.forEach(o=>{
    o.y += o.speed;
    o.x += Math.sin(ts/500 + o.phase) * 0.7;
  });
  state.objects = state.objects.filter(o=> o.y < canvas.height + 50);

  state.particles.forEach(p=>{ p.y -= 0.6; p.life -= dt; });
  state.particles = state.particles.filter(p=> p.life > 0);

  if (Math.floor(ts/1000) !== Math.floor((ts-dt)/1000)) {
    state.time--;
    timeBadge.textContent = `Waktu: ${state.time}s`;
    if (state.time<=5 && state.time>0) beep(900,0.05,"square",0.06);
    if (state.time<=0){ end(); return; }
  }

  render();
  requestAnimationFrame(loop);
}

/* =========================
   RENDER
   ========================= */
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(const o of state.objects){
    if (o.type==="heart") drawHeart(o.x,o.y,o.size);
    else drawBomb(o.x,o.y,o.size);
  }
  ctx.save();
  ctx.fillStyle = "#e11d48";
  ctx.font = "bold 18px system-ui, -apple-system, Segoe UI, Roboto";
  ctx.textAlign = "center";
  for(const p of state.particles){
    ctx.globalAlpha = Math.max(0, p.life/600);
    if (p.text){ ctx.fillText(p.text, p.x, p.y); }
  }
  ctx.globalAlpha = 1;
  ctx.restore();
}
function drawHeart(x,y,size){
  ctx.save(); ctx.translate(x,y); ctx.fillStyle = "#f43f5e";
  const s = size/24;
  ctx.beginPath();
  ctx.moveTo(12*s,21*s);
  ctx.bezierCurveTo(-12*s,7*s, 4*s,-4*s, 12*s,5*s);
  ctx.bezierCurveTo(20*s,-4*s, 36*s,7*s, 12*s,21*s);
  ctx.closePath(); ctx.fill(); ctx.restore();
}
function drawBomb(x,y,size){
  ctx.save(); ctx.translate(x,y);
  const r = size/2;
  ctx.fillStyle = "#111827";
  ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle = "#7c3042"; ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(r*0.2,-r*0.6); ctx.quadraticCurveTo(r*0.8,-r*1.1, r*1.2,-r*1.5); ctx.stroke();
  ctx.fillStyle = "#f59e0b"; ctx.beginPath(); ctx.arc(r*1.25,-r*1.55, r*0.18, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

/* =========================
   TAP INPUT ‚Äî FAST & ASSISTED
   ========================= */
function toCanvasPoint(e){
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width/rect.width);
  const y = (e.clientY - rect.top) * (canvas.height/rect.height);
  return {x,y, rectW: rect.width};
}
canvas.addEventListener("pointerdown", (e)=>{
  if (!state.running) return;
  unlockAudio(); // non-blocking
  const p = toCanvasPoint(e);

  // 1) precise hit (prefer heart)
  let hitIndex = -1, hitType = null;
  for (let i = state.objects.length - 1; i >= 0; i--) {
    const o = state.objects[i];
    if (hitPointObject(p, o, HIT_RADIUS_SCALE)){
      if (o.type === "heart") { hitIndex = i; hitType = "heart"; break; }
      else if (hitIndex === -1) { hitIndex = i; hitType = "bomb"; }
    }
  }
  // 2) aim assist to nearest heart
  if (hitIndex === -1){
    const maxCanvasDist = AIM_ASSIST_PX * (canvas.width / p.rectW);
    let bestI = -1, bestD2 = maxCanvasDist*maxCanvasDist;
    for (let i = state.objects.length - 1; i >= 0; i--) {
      const o = state.objects[i];
      if (o.type !== "heart") continue;
      const dx = p.x - o.x, dy = p.y - o.y;
      const d2 = dx*dx + dy*dy;
      if (d2 < bestD2){ bestD2 = d2; bestI = i; }
    }
    if (bestI !== -1){ hitIndex = bestI; hitType = "heart"; }
  }

  if (hitIndex !== -1){
    const o = state.objects[hitIndex];
    if (hitType === "heart"){
      state.score++;
      navigator.vibrate?.(10);
      beep(880,0.05,"sine",0.08);
      state.particles.push({ x:o.x, y:o.y, text:"+1", life:600 });
    } else {
      state.score = Math.max(0, state.score - 2);
      navigator.vibrate?.([24,28,24]);
      boom();
      state.particles.push({ x:o.x, y:o.y, text:"-2", life:600 });
    }
    scoreBadge.textContent = "Skor: " + state.score;
    state.objects.splice(hitIndex,1);
  }
}, { passive:true });

function hitPointObject(p, o, scale){
  const r = o.size * scale;
  const dx = p.x - o.x;
  const dy = p.y - o.y;
  return (dx*dx + dy*dy) <= r*r;
}

/* =========================
   BUTTONS
   ========================= */
startBtn.addEventListener("click", ()=>{ start(); });
playAgain.addEventListener("click", ()=>{ start(); });
muteBtn.addEventListener("click", ()=>{
  unlockAudio();
  soundMuted = !soundMuted;
  muteBtn.textContent = soundMuted ? "Sound: OFF üîá" : "Sound: ON üîä";
  muteBtn.style.background = soundMuted ? "#9a6d78" : "#7c3042";
});

</script>
</body>
</html>
